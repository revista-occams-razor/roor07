\hypertarget{pvc:password1}{}\label{pvc:password}
\pagestyle{pvc}

\rput(7.9,-0.5){\resizebox{!}{14cm}{{\epsfbox{images/password-header.eps}}}}

\psset{fillstyle=solid}
\psframe[fillcolor=black,opacity=0.7](2,-4.5)(17,0)





% -------------------------------------------------
% Cabecera
\begin{flushright}


{\color{pink}\mtitle{14cm}{Introduciendo contraseñas de forma segura}}

\msubtitle{8cm}{Como desactivar el echo de la consola}

{\sf\color{white}{ por Yvil Yenius}}

%{{\psset{linecolor=black,linestyle=dotted}\psline(-12,0)}}
\end{flushright}


\vspace{2mm}
% -------------------------------------------------
\lstset{language=C,frame=tb,framesep=5pt,basicstyle=\scriptsize}

\intro{introcolor}{C}{ualquier organización maligna que se precie debe proteger con
contraseñas absolutamente todo. Servidores, programas, acceso a bases de
datos. \textbf{TODO}. Añadir una contraseña a tu sistema es bastante
fácil, pero lo que quizás no sepas es como conseguir que esa contraseña
no se vea mientras la escribes. Pues en ese caso\ldots{} este es tu
artículo.}

\begin{multicols}{2}

Parece una tontería verdad, pero no es tan evidente. Como genia
diabólica he invertido muchos años en estudiar las mejores formas de
construir sistemas misteriosos y secretos y ahora, que he evolucionado
mi organización hacia tecnologías más sofisticadas, puedo compartir
alguna de esta valiosísima información, la cual, aunque obsoleta, puede
ser valiosa para alguno de vosotros.

\hypertarget{protegiendo-un-programa-con-contraseuxf1a}{%
\sectiontext{white}{black}{PROTEGIENDO UN PROGRAMA CON
CONTRASEÑA}\label{protegiendo-un-programa-con-contraseuxf1a}}

A modo de ejemplo vamos a comenzar con un pequeño programa de prueba con
el que trabajar. Se trata del primer servicio super secreto que incluí
en mi organización clandestina para mis secuaces. La verdad es que el
servicio no hacía nada, pero molaba mucho y a los secuaces les
encantaba. Este es el programa.

\begin{lstlisting}[language=C]
#include <stdio.h>
#include <string.h>

int main () {
  char clave[1024];
  
  puts ("Servicio Super Secreto");
  puts ("(c) Yvil Genius para IbolCorp, 2024\n");
  printf ("Contraseña ?  ");
  fflush (stdout);
  fgets (clave, 1024, stdin);
  if (strncmp (clave, "YvilRulez!", 10) != 0) {
    puts ("Acceso Denegado!");
    return 1;
  }
  puts ("Bienvenido secuaz! ");
  // Aquí empieza el servicio super secreto
  return 0;
}
\end{lstlisting}

El programa es muy básico, pero voy a hacer un par de comentarios para
los principiantes.

Hablaremos en un momento sobre los terminales, pero por defecto debes
saber que los terminales funcionan en lo que se llama \emph{Buffered
Mode} (realmente el modo tiene otro nombre, pero lo veremos en un rato).
En este modo, los caracteres que queremos imprimir o leer no se
transfieren a/desde nuestro programa inmediatamente sino que se
almacenan en una memoria intermedia. Lo que los anglosajones llaman
\emph{Buffer}. Cuando la memoria se llena o se cumple una cierta
codición, como por ejemplo que hemos enviado un caracter
\verb!\\n! (esto es pulsar
\verb!ENTER!), el buffer se imprime en pantalla o se
lee en nuestro programa.

Puesto que queremos que la contraseña se imprima justo al lado de el
\emph{prompt} ( \verb!Contraseña ?!), debemos forzar
la impresión del \emph{buffer} con \verb!fflush!. De
lo contrario, dependiendo del estado del sistema, la cadena
\verb!Contraseña ?! puede imprimirse antes o después
de introducir nuestra contraseña. Normalmente después, justo al pulsar
\verb!ENTER!.

\begin{entradilla}
{\em La función `fgets` incluye el retorno de carro en la cadena que devuelve}
\end{entradilla}

El otro comentario para principiantes es que
\verb!fgets! lee el retorno de carro. Es decir,
nuestra variable \verb!clave! contendrá un caracter
\verb!\\n! al final. Para lidiar con esto tenéis
varias opciones. Podéis eliminar el caracter con algo como
\verb!clave[strlen(clave) - 1] = 0! o ignorarlo como
he hecho yo en este ejemplo. Simplemente comparo 10 caracteres usando
\verb!strncmp! en lugar de
\verb!strcmp!, con lo cual el retorno de carro final
se deja fuera de la comparación.

\hypertarget{terminales}{%
\sectiontext{white}{black}{TERMINALES}\label{terminales}}

La forma de interactuar con un sistema UNIX es a través de un terminal.
En el principio de los tiempos se utilizaba una máquina especial llamada
terminal (eso no lo viste venir eh?) que se conectaba al ordenador,
normalmente, a través de un puerto serie. En la actualidad, utilizamos
emuladores de terminal que son, digamos, la versión software de aquellas
máquinas.

Estos terminales no hacían muchas cosas, pero tampoco eran simples
máquinas de escribir. Una de las cosas que permitían hacer era
configurarlos. El terminal en si tenía un sencillo software con el que
configurar distintas funcionalidades. También interpretaban comandos
especiales que hacían cosas como borrar la pantalla o moverte a una
posición concreta de la misma. Estos códigos se conocen como secuencias
de escape, ya que \emph{escapaban} del flujo de datos normales hacia el
ordenador, y estaban dirigidas al terminal. Había distintas secuencias
para los distintos tipos de terminales, pero se acabaron estandarizando
y hoy en día, los emuladores de terminal siguen soportando las
principales, siendo las secuencias \textbf{ANSI} las más populares y
estándar.

En general, manejar el terminal directamente es una tarea tediosa y
complicada, y los programas suelen optar por dos opciones:

\begin{itemize}
\item
  Obviar el terminal completamente y simplemente leer y escribir datos
  sin más como en mi primer servicio secreto super clandestino.
\item
  Utilizar alguna librería que maneje el terminal por nosotros. La
  libreríaa \verb!curses! es la más popular y la que
  utilizan la mayoría de programas que quieren controlar lo que se
  muestra en pantalla. Esto incluye, por ejemplo, el programa de
  configuración del kernel.
\end{itemize}

\hypertarget{ocultando-la-contraseuxf1a}{%
\sectiontext{white}{black}{OCULTANDO LA CONTRASEÑA}\label{ocultando-la-contraseuxf1a}}

Los terminales por defecto muestran en pantalla cualquier tecla que
pulsamos, siempre que no se trate de una tecla asociada a una secuencia
de control como por ejemplo \verb!BACKSPACE!. En ese
caso, la tecla es procesada. Los código de control suelen tener
asignados valores menores que 32, el cual representa la barra
espaciadora. Por ejemplo, el código \verb!8! se
reserva para \verb!BACKSPACE! y el
\verb!9! para el tabulador. Además de esos valores el
código \verb!127! representa la tecla
\verb!DEL!.

\begin{entradilla}
{\em Para evitar que nuestra contraseña se muestre en pantalla tenemos que desactivar el ECHO del terminal.}
\end{entradilla}

Esta función de imprimir las teclas que pulsamos se conoce como
\verb!ECHO! y está activa por defecto en todos los
terminales. La forma más sencilla de hacer que nuestra clave no se
muestre en pantalla es desactivar esta función mientras leemos la
contraseña. Para ello debemos reconfigurar nuestro terminal.

La forma de reconfigurar nuestro terminal es utilizar las funciones
\verb!tcgetattr! y
\verb!tcsetattr! que nos permiten leer y escribir
atributos del terminal. Para usar estas funciones debemos incluir
\verb!termios.h! en nuestro programa.

Veamos como quedaría el código y luego lo comentamos en detalle.

\begin{lstlisting}[language=C]
(...)
  struct termios term;
  
  tcgetattr (0, &term);
  term.c_lflag &= ~ECHO;
  tcsetattr (0, TCSANOW, &term);
  
  fgets (clave, 1024, stdin);
  
  term.c_lflag |= ECHO;
  tcsetattr (0, TCSANOW, &term);
(...)
\end{lstlisting}

\hypertarget{configurando-echo}{%
\sectiontext{white}{black}{CONFIGURANDO ECHO}\label{configurando-echo}}

La forma de interactuar con las funciones definidas en
\verb!termios.h! es usando la estructura
\verb!termios!, la cual contiene, al menos los
siguientes campos:

\begin{lstlisting}[language=C]
           tcflag_t c_iflag;      /* input modes */
           tcflag_t c_oflag;      /* output modes */
           tcflag_t c_cflag;      /* control modes */
           tcflag_t c_lflag;      /* local modes */
           cc_t     c_cc[NCCS];   /* special characters */
\end{lstlisting}

Estos son los campos que podemos manipular, y para el ejemplo que nos
ocupa, lo que nos interesa son los llamados \emph{local modes}. Usando
ese campo podemos activara y desactivar fácilmente la función de
\verb!ECHO!.

A efectos prácticos \verb!tcflag\_t! es un entero que
contiene distintos flags. El flag que controla el echo está asignado a
la constante \verb!ECHO! (definida en
\verb!termios,h!) que se corresponde con
\verb!0x08! o el cuarto bit si lo prefieres, si bien,
es recomendable utilizar la constante \verb!ECHO! en
lugar de el valor numérico. Así que sabiendo todo esto la forma de
desactivar el \emph{ECHO} del terminal es la siguiente:

\begin{itemize}
\item
  Leer la configuración actual. Esto lo tenemos que hacer ya que no
  podemos modificar un solo flag del terminal. Tenemos que modificarlos
  todos.
\item
  De la configuración actual modificamos el flag que controla el echo
  del terminal
\item
  Escribimos la configuración modificada.
\end{itemize}

En el código de la sección anterior, la forma de modificar el flag de
\verb!ECHO! es la siguiente:

\begin{lstlisting}[language=C]
  term.c_lflag &= ~ECHO;
\end{lstlisting}

Para los que no tengáis mucha práctica con el manejo de bits vamos a
descomponer esta expresión paso a paso. Imaginad que la constante
\verb!ECHO! tiene el valor
\verb!0x08! (lo cual es el caso para mi sistema
actual).

\begin{lstlisting}
XXXX XXXX XXXX XXXX   c_lflags
0000 0000 0000 1000   ECHO
1111 1111 1111 0111   ~ECHO
XXXX XXXX XXXX 0XXX   c_lflags & ~ECHO
\end{lstlisting}

Como podéis ver, la operación anterior borra el bit 4 de
\verb!c\_flags! sin tocar ninguno de los otros, que
es exactamente lo que queremos hacer. Una vez tenemos la nueva
configuración del terminal lista, simplemente la aplicamos con
\verb!tcsetattr! usando la opción
\verb!TCSANOW! para que los cambios se apliquen
inmediatamente. A partir de ese momento el \emph{ECHO} del terminal
estará desactivado y las teclas que pulsemos no se mostrarán en
pantalla.

Para reactivarlo, procedemos de la misma forma, pero esta vez
asegurándonos de que el flag que nos interesa está a 1.

\begin{lstlisting}[language=C]
   term.c_lflag |= ECHO;
\end{lstlisting}

En este caso solo necesitamos hacer un \verb!OR! con
el valor original, el cual pondrá a 1 ese bit independientemente del
valor que tuviera anteriormente.

El primer parámetro que pasamos a \verb!tcgetattr! y
\verb!tcsetattr! es el descriptor de ficheros de la
entrada estándar. En general este será el valor
\verb!0!.

Hemos conseguido no mostrar la contraseña en pantalla cuando la
escribimos, lo cual está genial, pero podemos hacerlo mejor.

\hypertarget{imprimiendo-estrellas}{%
\sectiontext{white}{black}{IMPRIMIENDO ESTRELLAS}\label{imprimiendo-estrellas}}

Si bien, nuestro programa cumple su finalidad, la experiencia de usuario
es muy mala. El usuario pulsa teclas pero parece que nada ocurre hasta
que al final pulsa \verb!ENTER!. Esa es la razón por
la que, tradicionalmente se imprime algo cuando se introduce una clave.

En aplicaciones de consola suele ser una estrella o asterisco. En
aplicaciones gráficas se suelen utilizar signos más guays. Nosotros
vamos a mostrar estrellas, y para ello debemos desactivar el modo
canónico del terminal. Os preguntaréis que es eso del modo
canónico\ldots{} bueno, ahora mismo os lo explico.

\hypertarget{modo-canuxf3nico}{%
\sectiontext{white}{black}{MODO CANÓNICO}\label{modo-canuxf3nico}}

Los terminales también ofrecen distintos modos de operación. El modo de
operación por defecto que asumen los sistemas GNU/Linux (y la mayoría de
otros UNIX) se conoce como modo canónico. En este modo ocurre lo
siguiente:

\begin{itemize}
\item
  La entrada de datos está disponible linea a linea. Esto significa que
  hasta que pulsemos \verb!ENTER! (o
  \verb!NL! \emph{NewLine}) o el caracter de fin de
  entrada de línea o de datos \verb!EOL! o
  \verb!EOF! los datos no se transferirán al
  programa. El caracter \verb!EOL! suele ser
  \verb!\\n! si bien esto se puede configurar. El
  caracter \verb!EOF! es por defecto
  \verb!CTRL+D!. Es posible configurar un segundo
  caracter de fin de línea, pero eso no nos aporta nada en este momento.
  Consultad la documentación si tenéis curiosidad,
\item
  La edición de línea está habilitada. Esto significa que las teclas
  \verb!BACKSPACE! o \verb!DEL!
  funcionan y se pueden utilizar para modificar los datos introducidos.
  Por ejemplo, \verb!BACKSPACE! tiene la secuencia de
  escape \verb!0x08!. En modo canónico, en lugar de
  añadir \verb!0x08! al \emph{buffer} que estamos
  leyendo, eliminamos el último caracter en el \emph{buffer}. En el
  programa de ejemplo podéis comprobarlo. Veremos en un segundo como
  esto no se cumple en otros modos.
\item
  El tamaño máximo de línea es 4096. Lineas de tamaños mayores se
  truncan a 4095. Cualquier dato por encima de eso se descarta pero se
  procesa de forma que caracteres de nueva línea que lleguen más tarde
  indicarán el fin de la entrad\ldots{} aunque una parte de esa entrada
  se descarte.
\end{itemize}

Así que, para poder imprimir una estrella cada vez que pulsamos una
tecla debemos desactivar el modo canónico puesto que de lo contrario no
podríamos hacer nada hasta que el usuario pulsara
\verb!ENTER!, que es lo que nos ha estado pasando
hasta ahora.

\hypertarget{desactivando-modo-canuxf3nico}{%
\sectiontext{white}{black}{DESACTIVANDO MODO
CANÓNICO}\label{desactivando-modo-canuxf3nico}}

Como acabamos de ver, lo primero que debemos hacer es desactivar el modo
canónico. Esto lo conseguimos modificando los modos locales, igual que
hicimos con la función de \emph{ECHO}. En este caso, ya que vamos a
modificar varios valores de la configuración, en lugar de activar y
desactivar los bits que nos interesan haremos una copia de los valores
originales de tal forma que podemos modificar todo lo que queramos sin
preocuparnos ya que utilizaremos el valor original de configuración para
restaurar el terminal.

Este es el código que debemos añadir:

\begin{lstlisting}[language=C]
    struct termios orig_term;
    struct termios new_term;
    
    tcgetattr (0, &orig_term);
    memcpy (&new_term, &orig_term, sizeof(struct termios));
    
    new_term.c_lflag &= ~(ICANON | ECHO);
    new_term.c_cc[VTIME] = 0;
    new_term.c_cc[VMIN] = 1;
    tcsetattr(0, 0, &new_term);
\end{lstlisting}

Como podéis ver esta vez leemos el valor original de la configuración
del terminal y a continuación hacemos una copia usando
\verb!memset!. Desde ese punto trabajamos sobre la
copia. La forma de desactivar \verb!ECHO! ya sabemos
como es y da la casualidad que el modo canónico no es más que otro flag
en el mismo campo de la estructura \verb!termios!. En
ese caso combinamos las dos máscaras
\verb!ICANON | ECHO! y las usamos a la vez.

\begin{entradilla}
{\em Para tener control completo del terminal debemos desactivar el modo canónico.}
\end{entradilla}


El valor por defecto de \verb!ICANON! es
\verb!0x02! (segundo bit activado), con esto podéis
intentar comprobar que el programa anterior desactiva los bits que
queremos (2 y 4).

A continuación utilizamos un nuevo campo de la estructura
\verb!termios!. De acuerdo a la documentación
\verb!man tcsetattr! los valores
\verb!VTIME! y \verb!VMIN! nos
permiten controlar como se leen los valores de la entrada estándar.

\begin{itemize}
\item
  \verb!VMIN! indica el número de caracteres mínimo a
  leer antes de retornar el valor a la aplicación (de hecho a la llamada
  al sistema \verb!read!). Este valor solo se aplica
  en modo no canónico. En este caso queremos leer un solo caracter o,
  dicho de otra forma, queremos que \verb!read!
  retorne cada vez que haya un caracter disponible (sin buffer).
\item
  \verb!VTIME! es el timeout. Nos permite indicar un
  tiempo tras el cual, si no hay suficientes caracteres disponibles
  \verb!read! retornará de todas formas. En este
  caso, el valor 0 significa timeout infinito y por lo tanto
  \verb!read! solo retornará cuando haya
  \verb!VMIN! caracteres disponibles.
\end{itemize}

Según la documentación (\verb!man tcgetattr! por
ejemplo), esta configuración se denomina \textbf{Lectura Bloqueante}.

En este punto nuestro terminal esta configurado para leer un solo
caracter de cada vez y con el \verb!ECHO!
desactivado. Escribamos el bucle para leer una contraseña.

\hypertarget{leyendo-la-contraseuxf1a}{%
\sectiontext{white}{black}{LEYENDO LA CONTRASEÑA}\label{leyendo-la-contraseuxf1a}}

Para leer la contraseña, ejecutaremos un bucle infinito en el que
leeremos caracter a caracter. Ahora ya no estamos en modo canónico y
nosotros tenemos que controlar cuando terminar la lectura. En nuestro
caso cuando se pulse la tecla \verb!ENTER! o se
introduzca el caracter \verb!\\n! si lo preferís.
Este es el código:

\begin{lstlisting}[language=C]
#define MAX_PASS 1024

    char c, indx = 0;
    do {
      read (0, &c, 1);
      if (c == '\n') break;
      clave[indx++] = c;
      write (1, "*", 1);
      if (indx > MAX_PASS) break;
    } while (1);

    tcsetattr(fileno(stdin), 0, &orig_term);
\end{lstlisting}

Sin sorpresas ¿verdad?. Leemos un caracter. Si es el fin de línea
terminamos y sino, lo almacenamos e imprimimos un asterisco. Finalmente,
si hemos alcanzado el tamaño máximo de nuestro buffer terminamos la
lectura de datos para evitar un desbordamiento de buffer.

Ahora, cada vez que pulsemos una tecla se imprimirá un asterisco como
queríamos.

No olvidéis incluir \verb!unistd.h! ya que ahora
estamos usando las funciones \verb!read! y
\verb!write!.

\hypertarget{siguientes-pasos}{%
\sectiontext{white}{black}{SIGUIENTES PASOS}\label{siguientes-pasos}}

Hasta aquí lo fundamental sobre este tema, pero no queremos irnos sin
dejaron un par de modificaciones que podéis intentar para practicar y
mejorar la entrada de contraseñas en vuestros programas.

La primera es la de procesar los caracteres de control. Ahora, puesto
que nuestro programa ya no está en modo canónico, no es posible la
edición de líneas (por razones obvias), sin embargo, podéis incorporar
código para procesar teclas especiales como
\verb!BACKSPACE! para borrar un caracter de la clave.
Tal y como está el programa ahora mismo, si pulsáis
\verb!BACKSPACE! ese caracter será parte de la clave.
Lo mismo con \verb!TAB! por ejemplo, es algo que, en
general, no debería permitirse en una clave.

La segunda es algo que he visto en algunos programas como por ejemplo en
Lotus Notes. Cuando introduces la clave el programa muestra un número
aleatorio de estrellas por cada pulsación, de forma que no puedes saber
cual es el tamaño de la clave contando las estrellitas. Dependiendo del
algoritmo utilizado, saber la longitud de la clave puede facilitar un
poco las cosas.

Como siempre no dudéis en enviarnos vuestras modificaciones o cualquier
duda que podáis tener respecto al artículo o cualquier variación del
código en la que trabajéis.

No desesperéis. Según haga más sofisticadas mis herramientas de
dominación del mundo iré compartiendo con vosotros técnicas más
avanzadas. Estad atentos si como yo queréis desarrollar el máximo
potencial de vuestra red de secuaces y haceros un nombre en la carrera
por dominar el mundo. JAJAJAJAJAJA (risa diabólica)
\end{multicols}
\rput(7.9,-4){\resizebox{!}{9.8cm}{{\epsfbox{images/promo/promo03.eps}}}}
